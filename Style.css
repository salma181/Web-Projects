"use strict";

/* ========= Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ®Ø²ÙŠÙ† ========= */
const STORAGE_KEY = "salma_todo_v1";

/* ========= Ø¹Ù†Ø§ØµØ± Ø§Ù„ØµÙØ­Ø© ========= */
const taskForm = document.getElementById("taskForm");
const taskInput = document.getElementById("taskInput");
const taskList = document.getElementById("taskList");
const searchInput = document.getElementById("searchInput");
const countText = document.getElementById("countText");
const doneText = document.getElementById("doneText");
const clearDoneBtn = document.getElementById("clearDone");
const clearAllBtn = document.getElementById("clearAll");
const toastEl = document.getElementById("toast");

const filterButtons = Array.from(document.querySelectorAll(".seg-btn"));

/* ========= Ø­Ø§Ù„Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ========= */
let tasks = loadTasks(); // [{id, text, done, createdAt}]
let currentFilter = "all";
let currentSearch = "";

/* ========= ØªØ´ØºÙŠÙ„ Ø£ÙˆÙ„ÙŠ ========= */
render();

/* ========= Ø£Ø­Ø¯Ø§Ø« ========= */
taskForm.addEventListener("submit", (e) => {
  e.preventDefault();
  addTask();
});

searchInput.addEventListener("input", () => {
  currentSearch = searchInput.value.trim().toLowerCase();
  render();
});

filterButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    filterButtons.forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
    currentFilter = btn.dataset.filter;
    render();
  });
});

clearDoneBtn.addEventListener("click", () => {
  const before = tasks.length;
  tasks = tasks.filter(t => !t.done);
  saveTasks();
  render();
  if (before === tasks.length) showToast("Ù…Ø§ ÙÙŠÙ‡ Ù…Ù‡Ø§Ù… Ù…Ù†Ø¬Ø²Ø© Ù„Ù…Ø³Ø­Ù‡Ø§ âœ…");
  else showToast("ØªÙ… Ù…Ø³Ø­ Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù…Ù†Ø¬Ø²Ø© âœ…");
});

clearAllBtn.addEventListener("click", () => {
  if (!tasks.length) return showToast("Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© ÙØ§Ø¶ÙŠØ© ğŸŒ¸");
  const ok = confirm("Ù…ØªØ£ÙƒØ¯Ø© ØªØ¨ØºÙŠ ØªÙ…Ø³Ø­ÙŠ ÙƒÙ„ Ø§Ù„Ù…Ù‡Ø§Ù…ØŸ");
  if (!ok) return;
  tasks = [];
  saveTasks();
  render();
  showToast("ØªÙ… Ù…Ø³Ø­ ÙƒÙ„ Ø§Ù„Ù…Ù‡Ø§Ù… âŒ");
});

/* Delegation Ù„Ù„Ø£Ø²Ø±Ø§Ø± Ø¯Ø§Ø®Ù„ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© */
taskList.addEventListener("click", (e) => {
  const btn = e.target.closest("button");
  if (!btn) return;

  const li = btn.closest("li");
  if (!li) return;

  const id = li.dataset.id;

  if (btn.classList.contains("done-btn")) {
    toggleDone(id);
  }

  if (btn.classList.contains("delete-btn")) {
    deleteTask(id);
  }

  if (btn.classList.contains("edit-btn")) {
    editTask(id);
  }
});

/* Enter Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù‡Ù…Ø© Ù„Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø³Ø±ÙŠØ¹ */
taskList.addEventListener("dblclick", (e) => {
  const textEl = e.target.closest(".text");
  if (!textEl) return;
  const li = textEl.closest("li");
  if (!li) return;
  editTask(li.dataset.id);
});

/* ========= Drag & Drop ========= */
let dragId = null;

taskList.addEventListener("dragstart", (e) => {
  const li = e.target.closest("li");
  if (!li) return;
  dragId = li.dataset.id;
  li.classList.add("dragging");
  e.dataTransfer.effectAllowed = "move";
});

taskList.addEventListener("dragend", (e) => {
  const li = e.target.closest("li");
  if (li) li.classList.remove("dragging");
  dragId = null;
});

taskList.addEventListener("dragover", (e) => {
  e.preventDefault();
  const afterEl = getDragAfterElement(taskList, e.clientY);
  const draggingEl = taskList.querySelector(".dragging");
  if (!draggingEl) return;

  if (afterEl == null) {
    taskList.appendChild(draggingEl);
  } else {
    taskList.insertBefore(draggingEl, afterEl);
  }
});

taskList.addEventListener("drop", () => {
  // Ø¨Ø¹Ø¯ Ù…Ø§ ÙŠØ®Ù„Øµ Ø³Ø­Ø¨ØŒ Ù†Ø­ÙØ¸ ØªØ±ØªÙŠØ¨ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø­Ø³Ø¨ DOM
  const orderedIds = Array.from(taskList.children).map(li => li.dataset.id);
  tasks.sort((a, b) => orderedIds.indexOf(a.id) - orderedIds.indexOf(b.id));
  saveTasks();
  showToast("ØªÙ… ØªØ±ØªÙŠØ¨ Ø§Ù„Ù…Ù‡Ø§Ù… âœ¨");
});

/* ========= ÙˆØ¸Ø§Ø¦Ù ========= */
function addTask() {
  const text = taskInput.value.trim();
  if (!text) return showToast("Ø§ÙƒØªØ¨ÙŠ Ù…Ù‡Ù…Ø© Ø£ÙˆÙ„Ù‹Ø§ âœï¸");
  if (text.length < 2) return showToast("Ø§ÙƒØªØ¨ÙŠÙ‡Ø§ Ø£ÙˆØ¶Ø­ Ø´ÙˆÙŠ ğŸŒ¸");

  const newTask = {
    id: crypto.randomUUID ? crypto.randomUUID() : String(Date.now()),
    text,
    done: false,
    createdAt: Date.now(),
  };

  tasks.unshift(newTask);
  taskInput.value = "";
  saveTasks();
  render();
  showToast("ØªÙ…Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ© âœ…");
}

function toggleDone(id) {
  const t = tasks.find(x => x.id === id);
  if (!t) return;
  t.done = !t.done;
  saveTasks();
  render();
  showToast(t.done ? "ØªÙ… âœ…" : "Ø±Ø¬Ø¹Ù†Ø§Ù‡Ø§ ØºÙŠØ± Ù…Ù†Ø¬Ø²Ø© ğŸŒ¸");
}

function deleteTask(id) {
  const t = tasks.find(x => x.id === id);
  tasks = tasks.filter(x => x.id !== id);
  saveTasks();
  render();
  showToast(`ØªÙ… Ø§Ù„Ø­Ø°Ù âŒ`);
}

function editTask(id) {
  const t = tasks.find(x => x.id === id);
  if (!t) return;

  const newText = prompt("Ø¹Ø¯Ù‘Ù„ÙŠ Ù†Øµ Ø§Ù„Ù…Ù‡Ù…Ø©:", t.text);
  if (newText === null) return; // cancel

  const trimmed = newText.trim();
  if (!trimmed) return showToast("Ù…Ø§ ÙŠÙ†ÙØ¹ ØªÙƒÙˆÙ† ÙØ§Ø¶ÙŠØ© ğŸ™ˆ");

  t.text = trimmed;
  saveTasks();
  render();
  showToast("ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ âœ¨");
}

function getVisibleTasks() {
  let list = [...tasks];

  // filter
  if (currentFilter === "active") list = list.filter(t => !t.done);
  if (currentFilter === "done") list = list.filter(t => t.done);

  // search
  if (currentSearch) {
    list = list.filter(t => t.text.toLowerCase().includes(currentSearch));
  }

  return list;
}

function render() {
  const visible = getVisibleTasks();

  // Counters
  const total = tasks.length;
  const done = tasks.filter(t => t.done).length;
  countText.textContent = `${total} Ù…Ù‡Ø§Ù…`;
  doneText.textContent = `${done} Ù…Ù†Ø¬Ø²`;

  // Render list
  taskList.innerHTML = "";

  if (!visible.length) {
    const empty = document.createElement("li");
    empty.className = "item";
    empty.innerHTML = `
      <div class="left">
        <span class="text" style="color:#777;font-weight:700;">Ù…Ø§ ÙÙŠÙ‡ Ù…Ù‡Ø§Ù… Ù‡Ù†Ø§â€¦ Ø§Ø¨Ø¯Ø£ÙŠ Ø¨Ø¥Ø¶Ø§ÙØ© Ù…Ù‡Ù…Ø© ğŸŒ¸</span>
      </div>
    `;
    taskList.appendChild(empty);
    return;
  }

  for (const t of visible) {
    const li = document.createElement("li");
    li.className = "item";
    li.dataset.id = t.id;
    li.setAttribute("draggable", "true");

    li.innerHTML = `
      <div class="left">
        <span class="drag" title="Ø§Ø³Ø­Ø¨ÙŠ Ù„Ù„ØªØ±ØªÙŠØ¨">â‹®â‹®</span>
        <span class="text ${t.done ? "done" : ""}">${escapeHtml(t.text)}</span>
      </div>

      <div class="actions">
        <button class="icon-btn done-btn done" type="button" title="ØªÙ… âœ…" aria-label="ØªÙ…">âœ…</button>
        <button class="icon-btn edit-btn edit" type="button" title="ØªØ¹Ø¯ÙŠÙ„ âœï¸" aria-label="ØªØ¹Ø¯ÙŠÙ„">âœï¸</button>
        <button class="icon-btn delete-btn del" type="button" title="Ø­Ø°Ù âŒ" aria-label="Ø­Ø°Ù">âŒ</button>
      </div>
    `;

    taskList.appendChild(li);
  }
}

function saveTasks() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(tasks));
}

function loadTasks() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    if (!Array.isArray(parsed)) return [];
    return parsed.map(t => ({
      id: String(t.id),
      text: String(t.text ?? ""),
      done: Boolean(t.done),
      createdAt: Number(t.createdAt ?? Date.now()),
    }));
  } catch {
    return [];
  }
}

function showToast(msg) {
  toastEl.textContent = msg;
  toastEl.classList.add("show");
  clearTimeout(showToast._t);
  showToast._t = setTimeout(() => toastEl.classList.remove("show"), 1800);
}

function escapeHtml(str) {
  return str
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

/* Drag helper */
function getDragAfterElement(container, y) {
  const draggableElements = [...container.querySelectorAll("li.item:not(.dragging)")];

  return draggableElements.reduce((closest, child) => {
    const box = child.getBoundingClientRect();
    const offset = y - box.top - box.height / 2;

    if (offset < 0 && offset > closest.offset) {
      return { offset, element: child };
    }
    return closest;
  }, { offset: Number.NEGATIVE_INFINITY, element: null }).element;
}
